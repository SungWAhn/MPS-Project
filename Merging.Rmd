---
title: "MPS Project -- Data Cleaning and Merging"
author: "Sung-Woo Ahn Wanwen Gu Yvonne Liu Xinyue Chen"
date: "March 4, 2019"
output:
  html_document:
    highlight: pygments
    theme: cosmo
---

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }

</style>

In this document, go over how we cleaned and merged the 6 datasets:

- gender_age_train.csv
- events.csv
- app_events.csv
- phone_brand_device_model.csv
-label_categories.csv
-app_labels.csv

Read in libraries
```{r warning=FALSE, message=FALSE}
library(knitr)
library(readr)
library(readxl)
library(data.table)
library(bit64)
library(Rmpfr)
library(tidyverse)
library(plyr)
library(kableExtra)
```
```{r echo=FALSE}
options(kableExtra.latex.load_packages = FALSE)
knit_hooks$set(document = function(x) {
  sub('\\usepackage[]{color}', '\\usepackage[]{xcolor}', x, fixed = TRUE)
})

```

## Data Import

```{r message=FALSE}
# Plain read.csv can take a while. fread from data.table library is much more efficient
events <- fread(file = 'events.csv', header = T, integer64 = "character")
app_events <- fread('app_events.csv', header = T, integer64 = "character")
app_labels <- fread('app_labels.csv', header = T, integer64 = "character")
labelcategory <- fread('label_standardized categories.csv', header = T, integer64 = "character")
gender_age <- fread('gender_age_train.csv', header = T, integer64 = "character")


# Use read_csv here because of the Chinese characters issue
phonebrand <- read_csv('phone_brand_device_model.csv', locale = locale(encoding = 'UTF-8'))
# Manually convert device_id to character type
phonebrand$device_id <- as.character(phonebrand$device_id)
```

- The id columns, like app_id and device_id are converted to character type for efficiency
- There is an issue with R not recognizing Chinese characters in the phone_brand_device_model file. Change the locale setting in read_csv to recognize Chinese characters. This didn't quite work, so we translated all columns with Chinese to English instead.

## Data Cleaning

### Translate Chinese characters in the phone brand and model columns

Created two excel files with translation keys; one for phone brand, and one for device model
```{r}
# Read in the translation dataset
chin_eng_brand <- read_excel("phone_brand-translate.xlsx", sheet = "Sheet1")
chin_eng_model <- read_excel("device_model translate.xlsx", sheet="Sheet1")
```
```{r results='asis'}
kable(chin_eng_brand[1:10,], caption = 'Preview of Phone Brand Translation Key') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
kable(chin_eng_model[1:10,], caption = 'Preview of Phone Model Translation Key') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

Use a for loop: if the Chinese phone brand or model name matches a name on our translation key, replace with its English equivalent
```{r}
# Replace each brand name with an english one with for loop
phone <- phonebrand$phone_brand
for (i in 1:121) {
  phone[phone==chin_eng_brand$`original phone brand`[i]] = chin_eng_brand$`new phone brand`[i]
}
phonebrand$phone_brand <- phone

# Replace each model name with an english one with for loop
model<-phonebrand$device_model
for (i in 1:68){
  model[model==chin_eng_model$`original model name`[i]]=chin_eng_model$`new model name`[i]
}
phonebrand$device_model<-model
```
Now check for any rows where Chinese characters are still left. If there are no alphabets, then basically assume its still Chinese character
```{r}
# Check to make sure that all Chinese characters have been replaced
leftoversbr <- phonebrand[which(grepl("[[:alnum:]]", phonebrand$phone_brand) == FALSE), ]
leftoversbr

leftoversmod <- phonebrand[which(grepl("[[:alnum:]]", phonebrand$device_model) == FALSE), ]
leftoversmod

```


- Use 

## Merging
Before merging the datasets, look at the properties of the datasets. Determine which columns are unique and which have duplicates.


**Main Points:**

- App_events: app_id and event_id not unique
- events: **unique** event_id and nonunique device_id
- app_labels: app_id and label_id not unique
- phonebrand: device_id not unique, but these duplicates have exactly same information
- gender_age: **unique** device_id

This means we can merge 

### events dataset
```{r}
# Any duplicate event_id? NO
dim(events[which(duplicated(events$event_id) == T),])
# Any duplicated device_id? YES
dim(events[which(duplicated(events$device_id) == T),])
```
```{r results='asis'}
# An of the example duplicates
kable(events[device_id==events[[81, 2]]][1:10,], caption = 'One device_id can have many Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
This dataset has a list of unique events, but multiple events could have same device_ids. The event_id is unique index.

### app_events datset
```{r}
# Any duplicate event_id? YES
dim(app_events[which(duplicated(app_events$event_id) == T),])
# Any duplicate app_id? YES
dim(app_events[which(duplicated(app_events$app_id) == T),])
```
```{r results='asis'}
# An example of the duplicates
kable(app_events[event_id == 568,][1:10], caption = 'Multiple Apps Used in One Event') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
kable(app_events[app_id == '6284164581582112235',][1:10], caption = 'Same Apps are used in Multiple Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
For every event_id, there are multiple app_ids associated. App_ids are not unique either. This dataset has no unique index.

### app_labels
```{r}
# Any duplicate app_id? YES
dim(app_labels[which(duplicated(app_labels$app_id) == T),])
# Any duplicated label_id? YES
dim(app_labels[which(duplicated(app_labels$label_id) == T),])
# An of the example duplicates
```
```{r results='asis'}
kable(app_labels[app_id==app_labels[[4, 1]],][1:10], caption = 'Apps Are Under Multiple Categories') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)

kable(app_labels[label_id==app_labels[[5, 2]],][1:10], caption = 'Multiple Apps Are Under Same Categories') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
Apps can be categorized under multiple label_ids, and many apps and the same labels are used multiple times for different apps. No unique index.

### label_category
```{r}
# Any duplicate label_id? NO
dim(labelcategory[which(duplicated(labelcategory$label_id) == T),])
# Any duplicated category? YES
dim(labelcategory[which(duplicated(labelcategory$`sub-category`) == T),])
```
```{r results='asis'}
# An of the example duplicates
kable(labelcategory[`sub-category`=="Medical"], caption = 'Some Label_id have same sub-category') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)

kable(labelcategory[category=="game"], caption = 'Many Label_id have same category') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
Label_id is unique. The text descriptions are not unique, so multiple label_ids can have the same text descriptions.

### Phonebrand dataset
```{r}
# Any duplicates in device_id? YES
dim(phonebrand[which(duplicated(phonebrand$device_id) == T),])
```
```{r results='asis'}
# Example duplicates
kable(phonebrand[phonebrand$device_id==phonebrand[[22626,1]],], caption = 'Some Device_id are repeated with exact same information') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)

kable(phonebrand[which(phonebrand$device_id==phonebrand[[34351,1]]),], caption = 'Some Device_id are repeated with exact same information') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
Looking at the examples, looks like the duplicates are the exact same individuals. Safe to delete?
```{r}
# Find device ids that are repeated
phonebrand2 <- phonebrand %>%
  group_by(device_id) %>%
  summarise(device_id.count = n()) %>%
  filter(device_id.count > 2) %>%
  arrange(device_id)
phonebrand2

phonebrand3 <- phonebrand %>%
  arrange(device_id) %>%
  filter(is.na(device_model) == FALSE)
phonebrand3

phoneduplicates = NULL

for (i in 1:(length(phonebrand3$device_id)-1)) {
  if(phonebrand3$device_id[i] == phonebrand3$device_id[i+1] & phonebrand3$device_model[i] != phonebrand3$device_model[i+1]) {
    phoneduplicates[i] = phonebrand3$device_id[i]
  } 
}
```


### Gender_age dataset
```{r}
# Any duplicate device_id? NO
dim(gender_age[which(duplicated(gender_age$device_id) == T),])
```
Gender_age has a unique device_id column. Every individual has a gender/age class.

### Merge Operations

Delete the duplicate rows in Phonebrand
```{r}
uniquephones <- unique(phonebrand)
```

Merge sequentially, starting with datasets that have unique indexes. 
First left join phonebrand with gender_age on device_id.
```{r results='asis'}
kable(gender_age[1:6, ], caption = 'Gender_Age') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
kable(phonebrand[1:6,], caption = 'Phonebrand') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
```{r}
# Convert uniquephones to a data.table to prevent any memory issues
merged1 <- merge(x = gender_age, y = setDT(uniquephones), by = 'device_id', all.x = T)
```
The result
```{r results='asis'}
kable(merged1[1:6,], caption = 'First Merge') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```


Second Merge: Inner Join the previous dataset with Events
```{r results='asis'}
kable(events[1:6,], caption = 'Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```
```{r}
merged2 <- merge(x = merged1, y = events, by = 'device_id', all.x = T)
merged2.noNA <- merged2[is.na(merged2$phone_brand)==FALSE | is.na(merged2$event_id)==FALSE]
```
The result
```{r results='asis'}
kable(merged2[1:6,], caption = 'Second Merge') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "12em") %>%
  column_spec(6, width = "6em")
```


The third merge. Left join the previous dataset with App_Events
```{r results='asis'}
kable(app_events[1:6,], caption = 'App_Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```
```{r}
train <- merge(x = merged2.noNA, y = app_events, by = 'event_id', all.x = T)
```
The result
```{r results='asis'}
kable(train[1:6,], caption = "Third Merge") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

There are still 2 datasets left pertaining to app descriptions
```{r results='asis'}
# Merge the app_label with label_category
kable(app_labels[1:6,], caption = 'App_Labels') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)

kable(labelcategory[1:6], caption = 'Label_Category') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
```{r}
labelsdat <- merge(x = app_labels, y = labelcategory, by = 'label_id', all.x = T)
```
```{r results='asis'}
kable(labelsdat[1:10,], caption = 'App Labels') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

```{r}
response <- train[, list(device_id, gender, age, group, app_id)]
```
```{r results='asis'}
kable(response[1:10,], caption = 'Response') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
```{r}
uniquelabels <- labelsdat %>%
  arrange(app_id) %>%
  group_by(app_id, category) %>%
  distinct(category)

```
```{r results='asis'}
kable(uniquelabels[1:10,], caption = 'UniqueLabels') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
```{r}
labeltrain <- merge(x = response, y = uniquelabels, by = 'app_id', all.x = T, allow.cartesian = T)
```
```{r results='asis'}
kable(labeltrain[1:10,], caption = 'Training+AppCategory') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

### Summary of the merges

```{r}
# Observation count
merge.dims <- data.frame("Table" = c("Gender_Age", "Previous + Phonebrand", "Previous + Events", "Previous + AppEvents"), "Join Type" = c("Starting Point", "Left Join", "Inner Join", "Left Join"), "Merge Key" = c("Device ID", "Device ID", "Device ID", "Event ID"), "Uniqueness" = c("Unique", "Unique", "Not Unique", "Not Unique"), "Obs Count" = c(dim(gender_age)[1], dim(merged1)[1], dim(merged2)[1], dim(train)[1]))
```
```{r results='asis'}
kable(merge.dims, caption = "Change in Length of Table") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(2, width = "12em")
```

```{r}
# Device id count
merge.idcount <- data.frame("Table" = c("Gender_Age", "Previous + Phonebrand", "Previous + Events", "Previous + AppEvents"), "Join Type" = c("Starting Point", "Left Join", "Inner Join", "Left Join"), "Merge Key" = c("Device ID", "Device ID", "Device ID", "Event ID"), "Uniqueness" = c("Unique", "Unique", "Not Unique", "Not Unique"), "Device ID Count" = c(length(unique(gender_age$device_id)), length(unique(merged1$device_id)), length(unique(merged2$device_id)), length(unique(train$device_id))))
```
```{r results='asis'}
kable(merge.idcount, caption = "Change in Device ID Count") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(2, width = "12em")
```

```{r}
# To check if we lose any observations that have phonebrand info but no events info
test<-merge(x = merged1[is.na(phone_brand) == FALSE], y = events, by = 'device_id')

# How many observations with phonebrand data?
dim(merged1[is.na(phone_brand)==FALSE])

# How many observations are left after the second merge?
test1 <- test %>%
distinct(device_id)
dim(test1)

dim(merged1[is.na(phone_brand)==FALSE])-dim(test1)
```
We lost 336 observations

To put them back in.
```{r eval=FALSE}
lostobs <- merged1[is.na(phone_brand)==FALSE, as.character.integer64(device_id) != as.character.integer64(test1$device_id), list(device_id)]
lostobs = NULL
for (i in 1:144) {
  if(any(as.character.integer64(merged1[is.na(phone_brand)==FALSE, device_id]) != as.character.integer64(test1$device_id[i]))) {
    lostobs[i] = as.character.integer64(test1$device_id[i])
  }
}
phonebrand2 <- phonebrand
phonebrand2$device_id <- as.character.integer64(phonebrand$device_id)
lostbsdf <- data.frame("device_id" = lostobs)
merge2lost <- merge(x = lostbsdf, y = phonebrand2, by = 'device_id', all.x = T)
```



```{r}
response <- train[, list(device_id, event_id, app_id)]

labeltrain2 <- merge(x = response, y = labelsdat, by = 'app_id', all.x = T, allow.cartesian = T)
labeltrain2 <- arrange(labeltrain, event_id)
```