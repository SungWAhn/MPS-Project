---
title: "MPS Project"
author: "Sung-Woo Ahn Wanwen Gu Yvonne Liu Xinyue Chen"
date: "February 13, 2019"
output: 
  html_document:
    theme: cosmo
---

<style type="text/css">

body{ /* Normal  */
      font-size: 18px;
  }

</style>

## Setup
```{r warning=FALSE, message=FALSE}
library(knitr)
library(readr)
library(data.table)
library(tidyverse)
library(bit64)
library(Rmpfr)
library(kableExtra)
options(kableExtra.latex.load_packages = FALSE)
knit_hooks$set(document = function(x) {
  sub('\\usepackage[]{color}', '\\usepackage[]{xcolor}', x, fixed = TRUE)
})

```
```{r}
# Plain setwd doesn't work for some reason
opts_knit$set(root.dir = 'C:/Users/sungw/Documents/School/Cornell/MPS Project/Demographic')
setwd('C:/Users/sungw/Documents/School/Cornell/MPS Project/Demographic')
```

There is an issue with R not recognizing Chinese characters. First tried to change the system locale, but this didn't work. Later tried changing the locale setting in read_csv, which sort of worked.
```{r}
# Plain read.csv can take a while. fread from data.table library is much more efficient
events <- fread(file = 'events.csv', header = T)
app_events <- fread('app_events.csv', header = T)
app_labels <- fread('app_labels.csv', header = T)
labelcategory <- fread('label_categories.csv', header = T)
gender_age <- fread('gender_age_train.csv', header = T)

# Use read_csv here because of the Chinese characters issue
phonebrand <- read_csv('phone_brand_device_model.csv', locale = locale(encoding = 'UTF-8'))
```

Before merging the datasets, look at the properties of the datasets. It is especially hard to plan the merges without knowing which columns are unique and which have duplicates.

### app_events datset
```{r}
# Any duplicate event_id? YES
dim(app_events[which(duplicated(app_events$event_id) == T),])
# Any duplicate app_id? YES
dim(app_events[which(duplicated(app_events$app_id) == T),])
# An example of the duplicates
app_events[which(app_events$event_id == 568),]
```
For every event_id, there are multiple app_ids associated. App_ids are not unique either. This dataset has no unique index.

### events dataset
```{r}
# Any duplicate event_id? NO
dim(events[which(duplicated(events$event_id) == T),])
# Any duplicated device_id? YES
dim(events[which(duplicated(events$device_id) == T),])

# An of the example duplicates
events[which(events$device_id==events[[81, 2]]),]
```
This dataset has a list of unique events, but events could share the same device_ids. The event_id is unique index.

### app_labels
```{r}
# Any duplicate app_id? YES
dim(app_labels[which(duplicated(app_labels$app_id) == T),])
# Any duplicated label_id? YES
dim(app_labels[which(duplicated(app_labels$label_id) == T),])
# An of the example duplicates
app_labels[which(app_labels$app_id==app_labels[[4, 1]]),]
app_labels[which(app_labels$label_id==app_labels[[5, 2]]),]
```
Any app_id can have multiple app_labels, and any app_label can have multiple app_ids. I.e. apps can be categorized under many labels, and the same labels are used multiple times for different apps. No unique index.

### label_category
```{r}
# Any duplicate label_id? NO
dim(labelcategory[which(duplicated(labelcategory$label_id) == T),])
# Any duplicated category? YES
dim(labelcategory[which(duplicated(labelcategory$category) == T),])

# An of the example duplicates
labelcategory[which(labelcategory$category==labelcategory[[106, 2]]),]
labelcategory[which(labelcategory$category==labelcategory[[187, 2]]),]
```
Label_id is unique. The text descriptions are not unique, so label_ids can have the same text descriptions.

### Phonebrand dataset
```{r}
# Any duplicates in device_id? YES
dim(phonebrand[which(duplicated(phonebrand$device_id) == T),])

# Example duplicates
phonebrand[which(phonebrand$device_id==phonebrand[[22626,1]]),]
phonebrand[which(phonebrand$device_id==phonebrand[[34351,1]]),]
```
Looking at the examples, looks like the duplicates are the exact same individuals. Safe to delete?

### Gender_age dataset
```{r}
# Any duplicate device_id? NO
dim(gender_age[which(duplicated(gender_age$device_id) == T),])
```
Gender_age has a unique device_id column. Every individual has a gneder/age class.

To summarize:

- App_events: no unique index
- events: **unique** event_id and nonunique device_id
- app_labels: nonunique app_id and nonunique label_id
- phonebrand: nonunique device_id, but these duplicates have exactly same rows
- gender_age: **unique** device_id


## Merging
This merge throws a warning because device_id is not unique in phonebrand
```{r}
# merged <- merge(x = appevents.events, y = phonebrand, by = 'device_id', all.x
# = TRUE)
```

Delete the duplicate rows in Phonebrand
```{r}
uniquephones <- unique(phonebrand)
```

Merge sequentially, starting with datasets that have unique indexes. 
First merge phonebrand with gender_age on device_id.
```{r results='asis', echo=FALSE}
kable(gender_age[1:6, ], caption = 'Gender_Age') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
kable(phonebrand[1:6,], caption = 'Phonebrand') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```
```{r}
# Convert uniquephones to a data.table to prevent any memory issues
merged1 <- merge(x = setDT(uniquephones), y = gender_age, by = 'device_id', all.y = T)
```
The result
```{r results='asis', echo=FALSE}
kable(merged1[1:6,], caption = 'First Merge') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```


Second Merge: Merge the previous dataset with Events
```{r results='asis', echo=FALSE}
kable(events[1:6,], caption = 'Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```
```{r}
merged2 <- merge(x = merged1, y = events, by = 'device_id')
```
The result
```{r results='asis', echo=FALSE}
kable(merged2[1:6,], caption = 'Second Merge') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "12em") %>%
  column_spec(6, width = "6em")
```


The third merge. Merge the previous dataset with App_Events
```{r results='asis', echo=FALSE}
kable(app_events[1:6,], caption = 'App_Events') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```
```{r}
train <- merge(x = merged2, y = app_events, by = 'event_id', all.x = T)
```
The result
```{r results='asis', echo=FALSE}
kable(train[1:6,], caption = "Third Merge") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

### Summary of the merges
```{r}
merge.dims <- data.frame("Table" = c("Gender_Age", "Merge1", "Merge2", "Train"), "Obs Count" = c(dim(gender_age)[1], dim(merged1)[1], dim(merged2)[1], dim(train)[1]))
```
```{r results='asis', echo=FALSE}
kable(merge.dims, caption = "Change in Length of Table") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(2, width = "12em")
```

```{r}
merge.idcount <- data.frame("Table" = c("Gender_Age", "Merge1", "Merge2", "Train"), "Device ID Count" = c(length(unique(gender_age$device_id)), length(unique(merged1$device_id)), length(unique(merged2$device_id)), length(unique(train$device_id))))
```
```{r results='asis', echo=FALSE}
kable(merge.idcount, caption = "Change in Device ID Count") %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(2, width = "12em")
```

There are still 2 datasets left pertaining to app descriptions
```{r results='asis', echo=FALSE}
# Merge the app_label with label_category
kable(app_labels[1:6,], caption = 'App_Labels') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")

kable(labelcategory[1:6], caption = 'Label_Category') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```
```{r}
labelsdat <- merge(x = app_labels, y = labelcategory, by = 'label_id', all.x = T)
```
```{r results='asis', echo=FALSE}
kable(labelsdat[1:10,], caption = 'App Labels') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F) %>%
  column_spec(1, width = "15em")
```



```{r}
# Maybe don't need to do this final merge?
# Convert the data.frames to a data.table to prevent any memory issues
#finalmerge <- merge(x = setDT(merged3), y = setDT(labelsdat), by = 'app_id', allow.cartesian = T, all.x = T)
```

## Exploratory Analysis

```{r}
inva_locations<-sum(train$longitude == 1 | train$longitude ==0 | train$latitude ==1 | train$latitude ==0)/length(train$longitude)

```
58% of the location data is invalid.

```{r}
ggplot(data = train, aes(x = factor(group))) +
  geom_bar(stat='count', width=0.7, fill="steelblue") +
  theme_minimal()
```

```{r}

m39 <- dim(train[which(train$group == 'M39+')])[1]
m32.38<- dim(train[which(train$group == 'M32-38')])[1]
m29.31<- dim(train[which(train$group == 'M29-31')])[1]
m27.28 <- dim(train[which(train$group == 'M27-28')])[1]
m23.26 <- dim(train[which(train$group == 'M23-26')])[1]
m22 <- dim(train[which(train$group == 'M22-')])[1]
f43 <- dim(train[which(train$group == 'F43+')])[1]
f33.42 <- dim(train[which(train$group == 'F33-42')])[1]
f29.32 <- dim(train[which(train$group == 'F29-32')])[1]
f27.28 <- dim(train[which(train$group == 'F27-28')])[1]
f24.26 <- dim(train[which(train$group == 'F24-26')])[1]
f23 <- dim(train[which(train$group == 'F23-')])[1]

groupcts <- data.frame('category' = c('M39+', 'M32-38', 'M29-31', 'M27-28', 'M23-26', 'M22-', 'F43+', 'F33-42', 'F29-32', 'F27-28', 'F24-26', 'F23-'), 'counts' = c(m39, m32.38, m29.31, m27.28, m23.26, m22, f43, f33.42, f29.32, f27.28, f24.26, f23))
```

```{r results='asis', echo=FALSE}
kable(groupcts, caption = 'Event Count by Group') %>%
  kable_styling(bootstrap_options = c("striped", "bordered", "responsive"), full_width = F)
```

```{r}
malecount <- sum(groupcts[1:6,2])
femalecount <- sum(groupcts[7:12,2])
percentage <- (malecount-femalecount)/malecount
percentage
```

There are 63% more males than females using their phones

```{r}
unique(train[which(train$group == 'M39+')]$phone_brand)
```
```{r}
m39.lenova<-dim(train[which(train$group=='M39+'& train$phone_brand=='??????')])[1]
phone_count=function(group) {
  lenova<-dim(train[which(train$group==group& train$phone_brand=='lenova')])[1]
  samsung<-dim(train[which(train$group==group & train$phone_brand=='samsung')])[1]
  ctyon<-dim(train[which(train$group==group & train$phone_brand=='ctyon')])[1]
  coolpad<-dim(train[which(train$group==group & train$phone_brand=='coolpad')])[1]
  vivo<-dim(train[which(train$group==group & train$phone_brand=='vivo')])[1]
  huawei<-dim(train[which(train$group==group & train$phone_brand=='huawei')])[1]
  gionee<-dim(train[which(train$group==group & train$phone_brand=='gionee')])[1]
  le<-dim(train[which(train$group==group & train$phone_brand=='le')])[1]
  meizu<-dim(train[which(train$group==group & train$phone_brand=='meizu')])[1]
  mi<-dim(train[which(train$group==group & train$phone_brand=='mi')])[1]
  meitu<-dim(train[which(train$group==group & train$phone_brand=='meitu')])[1]
  smartisan<-dim(train[which(train$group==group & train$phone_brand=='smartisan')])[1]
  yitong<-dim(train[which(train$group==group & train$phone_brand=='yitong')])[1]
  zte<-dim(train[which(train$group==group & train$phone_brand=='zte')])[1]
  koobee<-dim(train[which(train$group==group & train$phone_brand=='koobee')])[1]
  doov<-dim(train[which(train$group==group & train$phone_brand=='doov')])[1]
  nubia<-dim(train[which(train$group==group & train$phone_brand=='nubia')])[1]
  na<-dim(train[which(train$group==group & is.na(train$phone_brand))])[1]
  group_phone_count<-data.frame('phone_brand'=c('lenova','samsung', 'ctyon', 'coolpad', 'vivo', 'huawei', 'gionee', 'le','meizu','smartisan','yitong', 'zte', 'koobee', 'doov','nubia', 'na'), 'count'=c(lenova, samsung, ctyon, coolpad, vivo, huawei, gionee, le, meizu, smartisan, yitong, zte, koobee, doov, nubia, na))
  return(group_phone_count)
}
```